altair
pandas
streamlit

from flask import Flask, request, jsonify
from typing import Dict, Any, Optional, List, Tuple, Callable
import yaml
import json
import random
import datetime
import uuid
import re
from jsonschema import validate, ValidationError
from functools import wraps
import logging

class OpenAPIServer:
    def __init__(self, yaml_path: str):
        self.app = Flask(__name__)
        self.setup_logging()
        self.load_specification(yaml_path)
        self.setup_routes()

    def setup_logging(self):
        """Configure logging"""
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        )
        self.logger = logging.getLogger(__name__)

    def load_specification(self, yaml_path: str):
        """Load and parse OpenAPI specification"""
        try:
            with open(yaml_path, 'r') as file:
                self.spec = yaml.safe_load(file)
            self.logger.info(f"Successfully loaded OpenAPI specification from {yaml_path}")
        except Exception as e:
            self.logger.error(f"Failed to load specification: {str(e)}")
            raise

    def validate_request(self, schema: Dict) -> Callable:
        """Decorator for request validation"""
        def decorator(f):
            @wraps(f)
            def wrapper(*args, **kwargs):
                try:
                    if request.is_json:
                        data = request.get_json()
                    elif request.form:
                        data = dict(request.form)
                    else:
                        data = dict(request.args)

                    if schema:
                        validate(instance=data, schema=schema)
                    return f(*args, **kwargs)
                except ValidationError as e:
                    return jsonify({"error": "Validation failed", "details": str(e)}), 400
                except Exception as e:
                    return jsonify({"error": str(e)}), 500
            return wrapper
        return decorator

    def generate_mock_response(self, schema: Dict) -> Any:
        """Generate mock response based on schema"""
        if not schema:
            return None

        schema_type = schema.get('type', 'object')
        
        if schema_type == 'object':
            result = {}
            for prop, prop_schema in schema.get('properties', {}).items():
                result[prop] = self.generate_mock_response(prop_schema)
            return result

        elif schema_type == 'array':
            items_schema = schema.get('items', {})
            min_items = schema.get('minItems', 1)
            max_items = schema.get('maxItems', 5)
            num_items = random.randint(min_items, max_items)
            return [self.generate_mock_response(items_schema) for _ in range(num_items)]

        elif schema_type == 'string':
            format_type = schema.get('format', '')
            if format_type == 'date-time':
                return datetime.datetime.now().isoformat()
            elif format_type == 'date':
                return datetime.date.today().isoformat()
            elif format_type == 'email':
                return f"user{random.randint(1,1000)}@example.com"
            elif format_type == 'uuid':
                return str(uuid.uuid4())
            elif format_type == 'uri':
                return f"https://example.com/resource/{random.randint(1,1000)}"
            return f"sample_string_{random.randint(1,1000)}"

        elif schema_type == 'integer':
            minimum = schema.get('minimum', 0)
            maximum = schema.get('maximum', 1000)
            return random.randint(minimum, maximum)

        elif schema_type == 'number':
            minimum = schema.get('minimum', 0.0)
            maximum = schema.get('maximum', 1000.0)
            return round(random.uniform(minimum, maximum), 2)

        elif schema_type == 'boolean':
            return random.choice([True, False])

        return None

    def create_endpoint_handler(self, path: str, method: str, operation: Dict) -> Callable:
        """Create handler function for endpoint"""
        def handler(**kwargs):
            try:
                # Get response schema
                responses = operation.get('responses', {})
                success_code = next((code for code in responses.keys() 
                                  if str(code).startswith('2')), '200')
                response_schema = (responses.get(success_code, {})
                                .get('content', {})
                                .get('application/json', {})
                                .get('schema', {}))

                # Generate mock response
                response_data = self.generate_mock_response(response_schema)
                return jsonify(response_data), int(success_code)

            except Exception as e:
                self.logger.error(f"Error handling request: {str(e)}")
                return jsonify({"error": str(e)}), 500

        return handler

    def setup_routes(self):
        """Set up Flask routes based on OpenAPI specification"""
        paths = self.spec.get('paths', {})
        
        for path, path_item in paths.items():
            # Convert path parameters from OpenAPI to Flask format
            flask_path = re.sub(r'{([^}]+)}', r'<\1>', path)
            
            for method, operation in path_item.items():
                if method.lower() not in ['get', 'post', 'put', 'delete', 'patch']:
                    continue

                # Get request schema
                request_schema = (operation.get('requestBody', {})
                               .get('content', {})
                               .get('application/json', {})
                               .get('schema', {}))

                # Create handler with validation
                handler = self.validate_request(request_schema)(
                    self.create_endpoint_handler(path, method, operation)
                )

                # Register route
                self.app.route(flask_path, methods=[method.upper()])(handler)
                self.logger.info(f"Registered {method.upper()} {flask_path}")

    def add_error_handlers(self):
        """Add generic error handlers"""
        @self.app.errorhandler(404)
        def not_found(e):
            return jsonify({"error": "Not found"}), 404

        @self.app.errorhandler(405)
        def method_not_allowed(e):
            return jsonify({"error": "Method not allowed"}), 405

        @self.app.errorhandler(500)
        def server_error(e):
            return jsonify({"error": "Internal server error"}), 500

    def run(self, host: str = '0.0.0.0', port: int = 5000, debug: bool = True):
        """Run the Flask application"""
        self.add_error_handlers()
        self.app.run(host=host, port=port, debug=debug)

def create_server(yaml_path: str) -> OpenAPIServer:
    """Create and configure OpenAPI server"""
    return OpenAPIServer(yaml_path)

if __name__ == '__main__':
    import argparse
    
    parser = argparse.ArgumentParser(description='Start OpenAPI mock server')
    parser.add_argument('--yaml', required=True, help='Path to OpenAPI YAML file')
    parser.add_argument('--port', type=int, default=5000, help='Port to run server on')
    parser.add_argument('--host', default='0.0.0.0', help='Host to run server on')
    parser.add_argument('--debug', action='store_true', help='Enable debug mode')
    
    args = parser.parse_args()
    
    server = create_server(args.yaml)
    server.run(host=args.host, port=args.port, debug=args.debug)
