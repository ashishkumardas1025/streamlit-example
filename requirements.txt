altair
pandas
streamlit
###

from flask import Flask, jsonify, request
import yaml
import json
from typing import Dict, Any
import random
from functools import partial
import boto3
import os
from dotenv import load_dotenv

class FlaskAPISimulator:
    def __init__(self, config_path: str):
        """
        Initialize the API simulator with config file and AWS Bedrock
        """
        self.app = Flask(__name__)
        
        # Load environment variables
        load_dotenv()
        
        # Initialize AWS Bedrock client
        self.bedrock_runtime = boto3.client(
            service_name='bedrock-runtime',
            region_name=os.getenv('AWS_REGION', 'us-east-1'),
            aws_access_key_id=os.getenv('AWS_ACCESS_KEY_ID'),
            aws_secret_access_key=os.getenv('AWS_SECRET_ACCESS_KEY'),
            aws_session_token=os.getenv('AWS_SESSION_TOKEN')  # Optional, for temporary credentials
        )
        
        self.config = self._load_config(config_path)
        self._setup_routes()
    
    def _load_config(self, config_path: str) -> Dict:
        """
        Load and parse the YAML configuration file
        """
        with open(config_path, 'r') as file:
            return yaml.safe_load(file)
    
    def _setup_routes(self):
        """
        Dynamically create Flask routes based on the YAML configuration
        """
        for endpoint, config in self.config['endpoints'].items():
            path = config['path']
            method = config['method'].upper()
            
            # Create endpoint handler with the current config
            handler = partial(self._handle_request, config)
            
            # Register the route with Flask
            self.app.route(path, methods=[method])(handler)
    
    def _generate_dynamic_value(self, field_type: str, field_constraints: Dict = None) -> Any:
        """
        Generate dynamic values based on field type and constraints
        """
        if field_constraints is None:
            field_constraints = {}
            
        if field_type == 'string':
            return ''.join(random.choices('abcdefghijklmnopqrstuvwxyz', k=10))
        elif field_type == 'integer':
            min_val = field_constraints.get('minimum', 0)
            max_val = field_constraints.get('maximum', 100)
            return random.randint(min_val, max_val)
        elif field_type == 'number':
            min_val = field_constraints.get('minimum', 0)
            max_val = field_constraints.get('maximum', 100)
            return round(random.uniform(min_val, max_val), 2)
        elif field_type == 'boolean':
            return random.choice([True, False])
        elif field_type == 'array':
            items = field_constraints.get('items', {})
            size = random.randint(0, 5)
            return [self._generate_dynamic_value(items.get('type', 'string'), 
                                              items.get('constraints', {})) 
                   for _ in range(size)]
        elif field_type == 'object':
            return self._generate_basic_response(field_constraints)
        return None

    def _generate_response_with_claude(self, schema: Dict) -> Dict:
        """
        Use Claude via AWS Bedrock to generate a response matching the schema
        """
        prompt = f"""
        Generate a JSON response following this schema:
        {json.dumps(schema, indent=2)}
        
        The response should:
        1. Match all required fields and types
        2. Include realistic but randomized values
        3. Be properly formatted as JSON
        
        Response:
        """
        
        # Prepare the request body for Bedrock
        body = json.dumps({
            "prompt": prompt,
            "max_tokens": 1000,
            "temperature": 0.7,
            "anthropic_version": "bedrock-2023-05-31"
        })
        
        try:
            # Call Bedrock's Claude model
            response = self.bedrock_runtime.invoke_model(
                modelId='anthropic.claude-3-sonnet-20240229',  # Use appropriate model ID
                body=body
            )
            
            # Parse the response
            response_body = json.loads(response['body'].read())
            response_content = response_body.get('completion', '')
            
            # Extract JSON from Claude's response
            return json.loads(response_content)
        except Exception as e:
            print(f"Error calling Bedrock: {str(e)}")
            # Fallback to basic schema-based generation
            return self._generate_basic_response(schema)
    
    def _generate_basic_response(self, schema: Dict) -> Dict:
        """
        Generate a basic response following the schema without Claude
        """
        response = {}
        properties = schema.get('properties', {})
        
        for field_name, field_spec in properties.items():
            if 'type' in field_spec:
                response[field_name] = self._generate_dynamic_value(
                    field_spec['type'],
                    field_spec.get('constraints', {})
                )
        return response
    
    def _handle_request(self, endpoint_config: Dict):
        """
        Handle incoming requests and generate responses
        """
        try:
            response_schema = endpoint_config['response']['schema']
            
            # Use Claude for complex schemas, fallback to basic generation
            if endpoint_config.get('use_claude', False):
                response_data = self._generate_response_with_claude(response_schema)
            else:
                response_data = self._generate_basic_response(response_schema)
                
            return jsonify(response_data)
                
        except Exception as e:
            return jsonify({"error": str(e)}), 500
    
    def run(self, host: str = "0.0.0.0", port: int = 5000, debug: bool = False):
        """
        Run the API simulator
        """
        self.app.run(host=host, port=port, debug=debug)

# Example usage
if __name__ == "__main__":
    # Example configuration
    config_yaml = """
    endpoints:
      get_user:
        path: '/api/users/<user_id>'
        method: GET
        use_claude: true
        response:
          schema:
            type: object
            properties:
              id:
                type: integer
                constraints:
                  minimum: 1
                  maximum: 1000
              name:
                type: string
              email:
                type: string
              preferences:
                type: object
                properties:
                  theme:
                    type: string
                  notifications:
                    type: boolean
              saved_items:
                type: array
                items:
                  type: string
            required: [id, name, email]
    """
    
    # Save config to a temporary file
    with open("temp_config.yaml", "w") as f:
        f.write(config_yaml)
    
    # Initialize and run the simulator
    simulator = FlaskAPISimulator(config_path="temp_config.yaml")
    simulator.run(debug=True)
